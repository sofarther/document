1. $match:
	db.articles.aggregate( [
  { $match: { $or: [ { score: { $gt: 70, $lt: 90 } }, { views: { $gte: 1000 } } ] } },
  { $group: { _id: null, count: { $sum: 1 } } }
] );
	输出：
		{ "_id" : null, "count" : 5 }

2.$sort $limit $skip 在管道中执行顺序：
	（1）默认下会 按照指定的顺序执行：
	即 以下会先截取10条数据，然后再跳过5条， 最后再对剩余的5条数据进行排序
test>db.numbs.aggregate([{$limit:10},{$skip:5},{$sort:{num1:-1}}
{ "_id" : 8, "name" : "SPzjcGLOt", "num1" : 95, "num2" : 9 }
{ "_id" : 7, "name" : "exBe", "num1" : 93, "num2" : 4 }
{ "_id" : 6, "name" : "YPTLomeFZEc", "num1" : 90, "num2" : 11 }
{ "_id" : 10, "name" : "rSaUQpaoFZ", "num1" : 42, "num2" : 10 }
{ "_id" : 9, "name" : "yQjbUJziuNI", "num1" : 15, "num2" : 11 }

	（2）当 $limit 在 $skip 之后时，则会先执行$limit, 获取 $limit +$skip 条数据，
		然后再执行 $skip 跳过指定条记录
	test>db.numbs.aggregate([{$skip:5},{$limit:3},{$sort:{num1:-1}}])
{ "_id" : 8, "name" : "SPzjcGLOt", "num1" : 95, "num2" : 9 }
{ "_id" : 7, "name" : "exBe", "num1" : 93, "num2" : 4 }
{ "_id" : 6, "name" : "YPTLomeFZEc", "num1" : 90, "num2" : 11 }

		若将$limit 放在 $skip 之前：
		test>db.numbs.aggregate([{$limit:3},{$skip:5},{$sort:{num1:-1}}])
		则会先获取 3条数据， 再跳过 5条 ，故返回空

3.$unwind :将数组拆分为 每个元素为文档：
{ "_id" : 1, "name" : "sue", "age" : 19, "finished" : [ 17, 3 ] }

test>db.users.aggregate([{$project:{name:1,age:1,finished:1}},{$unwind:"$finished"}])
{ "_id" : 1, "name" : "sue", "age" : 19, "finished" : 17 }
{ "_id" : 1, "name" : "sue", "age" : 19, "finished" : 3 }
{ "_id" : 2, "name" : "bob", "age" : 42, "finished" : 11 }
{ "_id" : 2, "name" : "bob", "age" : 42, "finished" : 25 }
{ "_id" : 2, "name" : "bob", "age" : 42, "finished" : 22 }
{ "_id" : 3, "name" : "ahn", "age" : 22, "finished" : 6 }
{ "_id" : 4, "name" : "xi", "age" : 34, "finished" : 5 }
{ "_id" : 4, "name" : "xi", "age" : 34, "finished" : 11 }	

	可以对拆分后的文档进行匹配
	test>db.authors.aggregate([
			{$unwind:"$books"},
			{$match:{books:{$regex:/^the/i}
				}
			}
		])
	输出：
{ "_id" : "Homer", "books" : "The Odyssey" }
{ "_id" : "Dante", "books" : "The Banquet" }
4. $addFields添加新的返回字段:
	可以添加多次，每次可以添加多个字段
	当 添加的字段名 与已存在的字段名重复时，会覆盖原已存在的字段值 	
	db.numbs.aggregate([
		{$addFields:{
			sum:{$add:["$num1","$num2"]	
				},
			sub:{$subtract:["$num1","$num2"]}
			}
		},
		{$addFields:{
			sub1:{$subtract:["$num2","$num1"]}
			}
		}])
5.$out 将查询的结果 保存到指定的集合中
	当指定的集合名已存在时，会覆盖原集合中的文档
	test>db.numbs.aggregate([{$project:{
			num1:1,num2:1,
			sum:{$add:["$num1","$num2"]},
			sub:{$subtract:["$num1","$num2"]}
			}},
			{$out:"calc"}
		])
	test>db.books.aggregate([{$group:{_id:"$author",books:{$push:"$title"}}},
		{$out:"authors"}])

6.mapReduce()
	需 实现两个函数 Map 函数和 Reduce 函数 
	db.books.mapReduce(
		function(){ emit(this.author,this.copies);}, //map 函数
		function(key,values) {return Array.sum(values);}, //reduce 函数
		{out:"t"} // options
	)
	输出：
{
        "result" : "t", //储存结果的collection的名字,这是个临时集合，MapReduce的连接关闭后自动就被删除了
        "timeMillis" : 624, //执行花费的时间，毫秒为单位
        "counts" : {
                "input" : 5, //满足条件被发送到map函数的文档个数
                "emit" : 5, //在map函数中emit被调用的次数，也就是所有集合中的数据总量
                "reduce" : 2,
                "output" : 2  //结果集合中的文档个数
        },
        "ok" : 1
}
map 函数必须调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理
	emit的第一个参数是key，就是分组的依据，
	value，可以是要统计的数据
	this表示当前文档
reduce	函数会处理每一个分组，返回 新结果中的文档的value 键名的值
options 需指定 out 来指定保存结果的集合
	query 指定筛选条件只有满足条件的文档才会调用map函数
	sort 和limit
		执行后生成一个 t 集合：
			test>db.t.find()
				{ "_id" : "Dante", "value" : 5 }
				{ "_id" : "Homer", "value" : 20 }

	
	

	finalize 接受reduce 函数返回的内容，并处理返回处理后的结果
		test>db.books.mapReduce(
			function(){var value={tit:this.title,cop:this.copies}; 
					emit(this.author,value)
				},
			function(key,val){
				var tl=[]; cp=[];
			 	for(var i=0; i<val.length; i++){
					tl[i]=val[i].tit; cp[i]=val[i].cop;
				 }  
				return {t:tl,c:cp};
				},
			{	out:"t1",
			 	finalize:function(k,reduceVal){
					return {tt:reduceVal.t,cc:Array.sum(reduceVal.c)};
						}
			})
输出：
{
        "result" : "t1",
        "timeMillis" : 156,
        "counts" : {
                "input" : 5,
                "emit" : 5,
                "reduce" : 2,
                "output" : 2
        },
        "ok" : 1
}
查询结果
test>db.t1.find()
{ "_id" : "Dante", "value" : { "tt" : [ "The Banquet", "Divine Comedy", "Eclogues" ], "cc" : 5 } }
{ "_id" : "Homer", "value" : { "tt" : [ "The Odyssey", "Iliad" ], "cc" : 20 } }

	scope:{} 分配变量， 可在map reduce finalize 函数中使用
		test>db.books.mapReduce(
			function(){var value={tit:this.title,cop:this.copies}; 
					emit(this.author,value)
				},
			function(key,val){
				var tl=[]; cp=[];
			 	for(var i=0; i<val.length; i++){
					tl[i]=val[i].tit;
					if(val[i].cop>5){
						cp[i]=val[i].cop+p1;
					}else{
						cp[i]=val[i].cop+p2;
					}
					 
				 }  
				return {t:tl,c:cp};
				},
			{	out:"t1",
			 	finalize:function(k,reduceVal){
					return {tt:reduceVal.t,cc:Array.sum(reduceVal.c)};
						},
				scope:{p1:100,p2:300}
			})

reduce 函数必须能够处理map 中emit()  映射的键值，并且可以递归处理 reduce函数本身返回的结果，
	即 第二个参数 不一定是map 中调用emit()映射的键值，也可能是reduce函数的返回值
	因此 reduce 函数可能会多次调用，且调用的时机不一定是在map函数结束后执行
		
	test>db.records.mapReduce(
			function(){
					for(var k in this){emit(k,{count:1})}
			},
			function(key,values){
					var total=0; 
					for(var i=0; i<values.length; i++){
						total+=values[i].count;
					 } 
				return {count:total};
			 },
			{out:"t2"})
输出：
{
        "result" : "t2",
        "timeMillis" : 201,
        "counts" : {
                "input" : 4,
                "emit" : 14,
                "reduce" : 5,
                "output" : 7
        },
        "ok" : 1
}
test>db.t2.find()
{ "_id" : "_id", "value" : { "count" : 4 } }
{ "_id" : "a", "value" : { "count" : 2 } }
{ "_id" : "b", "value" : { "count" : 2 } }
{ "_id" : "c", "value" : { "count" : 2 } }
{ "_id" : "d", "value" : { "count" : 2 } }
{ "_id" : "e", "value" : { "count" : 1 } }
{ "_id" : "f", "value" : { "count" : 1 } }
说明：
	例如 集合中的文档：
		{_id:3,e:27,f:24,a:62}
	在map函数中遍历 当前文档的所有键名，调用 emit()，对每个键名指定映射的键值，
	产生一些键名和键值
	在对多个文档进行映射后，产生多个类似的{键名:{count:1}} 文档，然后按照键名进行分组 
	每个键名对应的键值为 多个 {count:1}的 数组，

	然后对每个键名和键值，调用reduce 函数
	对数组的元素的count 进行累加，并将累加后的结果返回，
	继续执行，直到键值的数组中只有一个元素，并将该元素返回 即为该键名对应的键值的最后结果	

7.distinct("") 去重指定的键名：
		test>db.records.distinct("b")
		输出： [ 54, 24 ]	

8.db.posts.insertMany([
{title:"java sun",author:"jk","day":"2012-12-14","tags":["java","spring","nosql"]},
{title:"ssh2的整合",author:"cj","day":"2012-5-10","tags":["struts 2","hibernate","spring"]},
{title:"C#的高级用法",author:"zt","day":"2012-4-3","tags":["c#","sql"]},
{title:"php mongodb",author:"lx","day":"2012-12-14","tags":["php","nosql","mongodb"]}
])

test>db.posts.group({
		"key":{"day":true},
		"initial":{tags:{}}, 
		"$reduce":function(doc,prev){
					for(i in doc.tags){ 
						if(doc.tags[i] in prev.tags)
						{
							prev.tags[doc.tags[i]]++; 
						}else{
							prev.tags[doc.tags[i]]=1;
						}
					}		
				}
	})
[
        {
                "day" : "2012-12-14",
                "tags" : {
                        "java" : 1,
                        "spring" : 1,
                        "nosql" : 2,
                        "php" : 1,
                        "mongodb" : 1
                }
        },
        {
                "day" : "2012-5-10",
                "tags" : {
                        "struts 2" : 1,
                        "hibernate" : 1,
                        "spring" : 1
                }
        },
        {
                "day" : "2012-4-3",
                "tags" : {
                        "c#" : 1,
                        "sql" : 1
                }
        }
]

//使用 mapReduce 实现：

db.posts.mapReduce(
	function(){
		var value={};
		for(i in this.tags)
		{
			if(!value[this.tags[i]])
			{
				value[this.tags[i]]=1;
			}
			else
			{
				value[this.tags[i]]++;	
			}
			
		}
		emit(this.day,value);
	},
	function(key,values)
	{
		var t=values[0];
		if(!t)
		{
			t={};
		}
		for(i=1; i<values.length; i++ )
		{
			for(k in values[i])
			{
				if(t[k]==undefined)
				{
					t[k]=values[i][k];
				}
				else{
					t[k]++;
				}
			}
		}
		return t;
	},
	{"out":"tt"}

)
说明：
	(1)reduce 函数不能返回 数组， 否则会报错：

		       "errmsg" : "reduce -> multiple not supported yet",
		因此在map 函数中 定义的 value 不能为[] ,


//将分组后的数组类型 合并到一个数组
test>db.posts.aggregate([{$unwind:"$tags"},
					{$group:{_id:"$day",
							 "tags":{$push:"$tags"}
							}
					}
				])
//或：
test>db.posts.aggregate([
			{$group:{_id:"$day",
					"tags":{$push:"$tags"}
					}
			},
			{$project:
				{"res":
					{$reduce:
						{input:"$tags",
							initialValue:[],
							in:{$concatArrays:["$$value","$$this"]}
						}
					}
				}
			}
		])			
{ "_id" : "2012-5-10", "tags" : [ "struts 2", "hibernate", "spring" ] }
{ "_id" : "2012-4-3", "tags" : [ "c#", "sql" ] }
{ "_id" : "2012-12-14", "tags" : [ "java", "spring", "nosql", "php", "nosql", "mongodb" ] }


group() 使用 finilize 指定处理最后结果函数：
	db.posts.group(
		{ "key":{"day":true},
			"initial":{tags:{}}, 
			"$reduce":function(doc,prev){ 
				for(i in doc.tags){  
					if(doc.tags[i] in prev.tags)
					{
						prev.tags[doc.tags[i]]++;  
					}
					else{ prev.tags[doc.tags[i]]=1; } 
			}
		},
		"finalize":function(prev){
			var maxpopular=0; 
			for(i in prev.tags)
			{
				if(prev.tags[i] > maxpopular)
				{
					prev.tag=i;
					maxpopular=prev.tags[i];
				} 
				
			} 
			delete prev.tags; 
		}
	} )
	finalize 指定 处理 每个分组的最后的键值 函数
输出：
[
        {
                "day" : "2012-12-14",
                "tag" : "nosql"
        },
        {
                "day" : "2012-5-10",
                "tag" : "struts 2"
        },
        {
                "day" : "2012-4-3",
                "tag" : "c#"
        }
]
使用 mapReduce()实现：
db.posts.mapReduce(
	function(){
		var value={};
		for(i in this.tags)
		{
			if(!value[this.tags[i]])
			{
				value[this.tags[i]]=1;
			}
			else
			{
				value[this.tags[i]]++;	
			}
			
		}
		emit(this.day,value);
	},
	function(key,values)
	{
		var t=values[0];
		if(!t)
		{
			t={};
		}
		for(i=1; i<values.length; i++ )
		{
			for(k in values[i])
			{
				if(t[k]==undefined)
				{
					t[k]=values[i][k];
				}
				else{
					t[k]++;
				}
			}
		}
		return t;
	},
	{"out":"tt",
		"finalize":function(k,reduceVal){
			var maxcount=0;
			var s="";
			for(i in reduceVal)
			{
				if(reduceVal[i]>maxcount)
				{
					maxcount=reduceVal[i];
					s=i;
				}
			}
		return {"dt":k,"tag":s};	
		}
		
	}

)
输出：
[
        {
                "day" : "2012-12-14",
                "tag" : "nosql"
        },
        {
                "day" : "2012-5-10",
                "tag" : "struts 2"
        },
        {
                "day" : "2012-4-3",
                "tag" : "c#"
        }
]

修改副本集成员配置时的限制：
1、不能修改_id；
	当 rs.initiate() 在两个节点上执行后 ，则两个节点创建的单机节点中
		members:[{_id:0}], _id 为0，
	此时不能将其中一个节点添加到另一个节点成员：
		会报错：
			 failed with Received heartbeat from member with the same member ID as ourself: 0	
		因此需要对其中的一个节点重新初始化，
		a. 停止mongod 服务，
		b. 将 配置的 dbpath 目录下的文件全部删除
		c. 按照原来的参数重启 mongod 服务，
		d.在另一个节点 执行添加节点成员：
				rs.add("192.168.1.127:27017")
		此时192.168.1.127 节点上的mongod 服务已作为副本集 存在
	说明：
		(1)添加节点时， 若 主节点的地址为 localhost 或 127.0.0.1 时，则不能添加其他IP地址的节点
2、不能讲接收rs.reconfig命令的成员的优先级设置为 0；
3、不能将仲裁者成员变为非仲裁者成员，反正亦然；
4、不能讲 buildIndexes：false 改为 true；

批量杀死进程;
	ps -ef | grep "mongos" | grep -v grep | awk '{print $2}' | xargs kill -2

配置 分片：
	（1）启动每个配置服务器，
			启动参数：
				#数据目录
				dbpath=/usr/local/config/
				#日志文件
				logpath=/var/log/mongodb/mongodb_config.log
				#日志追加
				logappend=true
				#端口
				port = 20000
				#最大连接数
				maxConns = 50
				pidfilepath = /var/run/mongo_20000.pid
				#日志,redo log
				journal = true
				#刷写提交机制
				journalCommitInterval = 200
				#守护进程模式
				fork = true
				#刷写数据到日志的频率
				syncdelay = 60
				#storageEngine = wiredTiger
				#操作日志,单位M
				oplogSize = 1000
				#命名空间的文件大小,默认16M，最大2G。
				nssize = 16
				noauth = true
				unixSocketPrefix = /tmp
				configsvr = true 
				replSet=Test
		说明：	
			a. 在3.2版本，mongos 路由服务配置参数 configdb的方式已经变成了：
					configReplSet/<cfgsvr1:port1>	
				即必须指定 复制集名， 故配置服务器启动时必须以 replSet 参数启动
			b. 配置服务器 需添加 configsvr 参数		
	（2）连接到其中的一个配置服务器 
		初始化配置复制集
		var config={_id:"Test",members:[{_id:0,"host":"192.168.1.102:20000"},{_id:1,host:"192.168.1.127:20000"}]}
		rs.initiate(config)
		在配置复制集前，不要连接多个配置服务器，否则在初始化时，会报错 data 不为空，	
				此时需将该配置服务器的数据目录下的文件清空
	（3）启动路由服务器 mongos
			启动参数：
				logpath=D:\Program Files\MongoDB\mongos\mongodb.log 
				logappend=true 
				quiet=true 
				port=30000
				configdb=Test/192.168.1.102:20000,192.168.1.127:20000
			其中 configdb 来指定 配置服务器的地址和端口，但需指定复制集名	