1. $match:
	db.articles.aggregate( [
  { $match: { $or: [ { score: { $gt: 70, $lt: 90 } }, { views: { $gte: 1000 } } ] } },
  { $group: { _id: null, count: { $sum: 1 } } }
] );
	输出：
		{ "_id" : null, "count" : 5 }

2.$sort $limit $skip 在管道中执行顺序：
	（1）默认下会 按照指定的顺序执行：
	即 以下会先截取10条数据，然后再跳过5条， 最后再对剩余的5条数据进行排序
test>db.numbs.aggregate([{$limit:10},{$skip:5},{$sort:{num1:-1}}
{ "_id" : 8, "name" : "SPzjcGLOt", "num1" : 95, "num2" : 9 }
{ "_id" : 7, "name" : "exBe", "num1" : 93, "num2" : 4 }
{ "_id" : 6, "name" : "YPTLomeFZEc", "num1" : 90, "num2" : 11 }
{ "_id" : 10, "name" : "rSaUQpaoFZ", "num1" : 42, "num2" : 10 }
{ "_id" : 9, "name" : "yQjbUJziuNI", "num1" : 15, "num2" : 11 }

	（2）当 $limit 在 $skip 之后时，则会先执行$limit, 获取 $limit +$skip 条数据，
		然后再执行 $skip 跳过指定条记录
	test>db.numbs.aggregate([{$skip:5},{$limit:3},{$sort:{num1:-1}}])
{ "_id" : 8, "name" : "SPzjcGLOt", "num1" : 95, "num2" : 9 }
{ "_id" : 7, "name" : "exBe", "num1" : 93, "num2" : 4 }
{ "_id" : 6, "name" : "YPTLomeFZEc", "num1" : 90, "num2" : 11 }

		若将$limit 放在 $skip 之前：
		test>db.numbs.aggregate([{$limit:3},{$skip:5},{$sort:{num1:-1}}])
		则会先获取 3条数据， 再跳过 5条 ，故返回空

3.$unwind :将数组拆分为 每个元素为文档：
{ "_id" : 1, "name" : "sue", "age" : 19, "finished" : [ 17, 3 ] }

test>db.users.aggregate([{$project:{name:1,age:1,finished:1}},{$unwind:"$finished"}])
{ "_id" : 1, "name" : "sue", "age" : 19, "finished" : 17 }
{ "_id" : 1, "name" : "sue", "age" : 19, "finished" : 3 }
{ "_id" : 2, "name" : "bob", "age" : 42, "finished" : 11 }
{ "_id" : 2, "name" : "bob", "age" : 42, "finished" : 25 }
{ "_id" : 2, "name" : "bob", "age" : 42, "finished" : 22 }
{ "_id" : 3, "name" : "ahn", "age" : 22, "finished" : 6 }
{ "_id" : 4, "name" : "xi", "age" : 34, "finished" : 5 }
{ "_id" : 4, "name" : "xi", "age" : 34, "finished" : 11 }	

	可以对拆分后的文档进行匹配
	test>db.authors.aggregate([
			{$unwind:"$books"},
			{$match:{books:{$regex:/^the/i}
				}
			}
		])
	输出：
{ "_id" : "Homer", "books" : "The Odyssey" }
{ "_id" : "Dante", "books" : "The Banquet" }
4. $addFields添加新的返回字段:
	可以添加多次，每次可以添加多个字段
	当 添加的字段名 与已存在的字段名重复时，会覆盖原已存在的字段值 	
	db.numbs.aggregate([
		{$addFields:{
			sum:{$add:["$num1","$num2"]	
				},
			sub:{$subtract:["$num1","$num2"]}
			}
		},
		{$addFields:{
			sub1:{$subtract:["$num2","$num1"]}
			}
		}])
5.$out 将查询的结果 保存到指定的集合中
	当指定的集合名已存在时，会覆盖原集合中的文档
	test>db.numbs.aggregate([{$project:{
			num1:1,num2:1,
			sum:{$add:["$num1","$num2"]},
			sub:{$subtract:["$num1","$num2"]}
			}},
			{$out:"calc"}
		])
	test>db.books.aggregate([{$group:{_id:"$author",books:{$push:"$title"}}},
		{$out:"authors"}])

6.mapReduce()
	需 实现两个函数 Map 函数和 Reduce 函数 
	db.books.mapReduce(
		function(){ emit(this.author,this.copies);}, //map 函数
		function(key,values) {return Array.sum(values);}, //reduce 函数
		{out:"t"} // options
	)
	输出：
{
        "result" : "t", //储存结果的collection的名字,这是个临时集合，MapReduce的连接关闭后自动就被删除了
        "timeMillis" : 624, //执行花费的时间，毫秒为单位
        "counts" : {
                "input" : 5, //满足条件被发送到map函数的文档个数
                "emit" : 5, //在map函数中emit被调用的次数，也就是所有集合中的数据总量
                "reduce" : 2,
                "output" : 2  //结果集合中的文档个数
        },
        "ok" : 1
}
map 函数必须调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理
	emit的第一个参数是key，就是分组的依据，
	value，可以是要统计的数据
	this表示当前文档
reduce	函数会处理每一个分组，返回 新结果中的文档的value 键名的值
options 需指定 out 来指定保存结果的集合
	query 指定筛选条件只有满足条件的文档才会调用map函数
	sort 和limit
		执行后生成一个 t 集合：
			test>db.t.find()
				{ "_id" : "Dante", "value" : 5 }
				{ "_id" : "Homer", "value" : 20 }

	
	

	finalize 接受reduce 函数返回的内容，并处理返回处理后的结果
		test>db.books.mapReduce(
			function(){var value={tit:this.title,cop:this.copies}; 
					emit(this.author,value)
				},
			function(key,val){
				var tl=[]; cp=[];
			 	for(var i=0; i<val.length; i++){
					tl[i]=val[i].tit; cp[i]=val[i].cop;
				 }  
				return {t:tl,c:cp};
				},
			{	out:"t1",
			 	finalize:function(k,reduceVal){
					return {tt:reduceVal.t,cc:Array.sum(reduceVal.c)};
						}
			})
输出：
{
        "result" : "t1",
        "timeMillis" : 156,
        "counts" : {
                "input" : 5,
                "emit" : 5,
                "reduce" : 2,
                "output" : 2
        },
        "ok" : 1
}
查询结果
test>db.t1.find()
{ "_id" : "Dante", "value" : { "tt" : [ "The Banquet", "Divine Comedy", "Eclogues" ], "cc" : 5 } }
{ "_id" : "Homer", "value" : { "tt" : [ "The Odyssey", "Iliad" ], "cc" : 20 } }

	scope:{} 分配变量， 可在map reduce finalize 函数中使用
		test>db.books.mapReduce(
			function(){var value={tit:this.title,cop:this.copies}; 
					emit(this.author,value)
				},
			function(key,val){
				var tl=[]; cp=[];
			 	for(var i=0; i<val.length; i++){
					tl[i]=val[i].tit;
					if(val[i].cop>5){
						cp[i]=val[i].cop+p1;
					}else{
						cp[i]=val[i].cop+p2;
					}
					 
				 }  
				return {t:tl,c:cp};
				},
			{	out:"t1",
			 	finalize:function(k,reduceVal){
					return {tt:reduceVal.t,cc:Array.sum(reduceVal.c)};
						},
				scope:{p1:100,p2:300}
			})

reduce 函数必须能够处理map 中emit()  映射的键值，并且可以递归处理 reduce函数本身返回的结果，
	即 第二个参数 不一定是map 中调用emit()映射的键值，也可能是reduce函数的返回值
	因此 reduce 函数可能会多次调用，且调用的时机不一定是在map函数结束后执行
		
	test>db.records.mapReduce(
			function(){
					for(var k in this){emit(k,{count:1})}
			},
			function(key,values){
					var total=0; 
					for(var i=0; i<values.length; i++){
						total+=values[i].count;
					 } 
				return {count:total};
			 },
			{out:"t2"})
输出：
{
        "result" : "t2",
        "timeMillis" : 201,
        "counts" : {
                "input" : 4,
                "emit" : 14,
                "reduce" : 5,
                "output" : 7
        },
        "ok" : 1
}
test>db.t2.find()
{ "_id" : "_id", "value" : { "count" : 4 } }
{ "_id" : "a", "value" : { "count" : 2 } }
{ "_id" : "b", "value" : { "count" : 2 } }
{ "_id" : "c", "value" : { "count" : 2 } }
{ "_id" : "d", "value" : { "count" : 2 } }
{ "_id" : "e", "value" : { "count" : 1 } }
{ "_id" : "f", "value" : { "count" : 1 } }
说明：
	例如 集合中的文档：
		{_id:3,e:27,f:24,a:62}
	在map函数中遍历 当前文档的所有键名，调用 emit()，对每个键名指定映射的键值，
	产生一些键名和键值
	在对多个文档进行映射后，产生多个类似的{键名:{count:1}} 文档，然后按照键名进行分组 
	每个键名对应的键值为 多个 {count:1}的 数组，

	然后对每个键名和键值，调用reduce 函数
	对数组的元素的count 进行累加，并将累加后的结果返回，
	继续执行，直到键值的数组中只有一个元素，并将该元素返回 即为该键名对应的键值的最后结果	

7.distinct("") 去重指定的键名：
		test>db.records.distinct("b")
		输出： [ 54, 24 ]	

8.db.posts.insertMany([
{title:"java sun",author:"jk","day":"2012-12-14","tags":["java","spring","nosql"]},
{title:"ssh2的整合",author:"cj","day":"2012-5-10","tags":["struts 2","hibernate","spring"]},
{title:"C#的高级用法",author:"zt","day":"2012-4-3","tags":["c#","sql"]},
{title:"php mongodb",author:"lx","day":"2012-12-14","tags":["php","nosql","mongodb"]}
])

test>db.posts.group({
		"key":{"day":true},
		"initial":{tags:{}}, 
		"$reduce":function(doc,prev){
					for(i in doc.tags){ 
						if(doc.tags[i] in prev.tags)
						{
							prev.tags[doc.tags[i]]++; 
						}else{
							prev.tags[doc.tags[i]]=1;
						}
					}		
				}
	})
[
        {
                "day" : "2012-12-14",
                "tags" : {
                        "java" : 1,
                        "spring" : 1,
                        "nosql" : 2,
                        "php" : 1,
                        "mongodb" : 1
                }
        },
        {
                "day" : "2012-5-10",
                "tags" : {
                        "struts 2" : 1,
                        "hibernate" : 1,
                        "spring" : 1
                }
        },
        {
                "day" : "2012-4-3",
                "tags" : {
                        "c#" : 1,
                        "sql" : 1
                }
        }
]

//使用 mapReduce 实现：

db.posts.mapReduce(
	function(){
		var value={};
		for(i in this.tags)
		{
			if(!value[this.tags[i]])
			{
				value[this.tags[i]]=1;
			}
			else
			{
				value[this.tags[i]]++;	
			}
			
		}
		emit(this.day,value);
	},
	function(key,values)
	{
		var t=values[0];
		if(!t)
		{
			t={};
		}
		for(i=1; i<values.length; i++ )
		{
			for(k in values[i])
			{
				if(t[k]==undefined)
				{
					t[k]=values[i][k];
				}
				else{
					t[k]++;
				}
			}
		}
		return t;
	},
	{"out":"tt"}

)
说明：
	(1)reduce 函数不能返回 数组， 否则会报错：

		       "errmsg" : "reduce -> multiple not supported yet",
		因此在map 函数中 定义的 value 不能为[] ,


//将分组后的数组类型 合并到一个数组
test>db.posts.aggregate([{$unwind:"$tags"},
					{$group:{_id:"$day",
							 "tags":{$push:"$tags"}
							}
					}
				])
//或：
test>db.posts.aggregate([
			{$group:{_id:"$day",
					"tags":{$push:"$tags"}
					}
			},
			{$project:
				{"res":
					{$reduce:
						{input:"$tags",
							initialValue:[],
							in:{$concatArrays:["$$value","$$this"]}
						}
					}
				}
			}
		])			
{ "_id" : "2012-5-10", "tags" : [ "struts 2", "hibernate", "spring" ] }
{ "_id" : "2012-4-3", "tags" : [ "c#", "sql" ] }
{ "_id" : "2012-12-14", "tags" : [ "java", "spring", "nosql", "php", "nosql", "mongodb" ] }


group() 使用 finilize 指定处理最后结果函数：
	db.posts.group(
		{ "key":{"day":true},
			"initial":{tags:{}}, 
			"$reduce":function(doc,prev){ 
				for(i in doc.tags){  
					if(doc.tags[i] in prev.tags)
					{
						prev.tags[doc.tags[i]]++;  
					}
					else{ prev.tags[doc.tags[i]]=1; } 
			}
		},
		"finalize":function(prev){
			var maxpopular=0; 
			for(i in prev.tags)
			{
				if(prev.tags[i] > maxpopular)
				{
					prev.tag=i;
					maxpopular=prev.tags[i];
				} 
				
			} 
			delete prev.tags; 
		}
	} )
	finalize 指定 处理 每个分组的最后的键值 函数
输出：
[
        {
                "day" : "2012-12-14",
                "tag" : "nosql"
        },
        {
                "day" : "2012-5-10",
                "tag" : "struts 2"
        },
        {
                "day" : "2012-4-3",
                "tag" : "c#"
        }
]
使用 mapReduce()实现：
db.posts.mapReduce(
	function(){
		var value={};
		for(i in this.tags)
		{
			if(!value[this.tags[i]])
			{
				value[this.tags[i]]=1;
			}
			else
			{
				value[this.tags[i]]++;	
			}
			
		}
		emit(this.day,value);
	},
	function(key,values)
	{
		var t=values[0];
		if(!t)
		{
			t={};
		}
		for(i=1; i<values.length; i++ )
		{
			for(k in values[i])
			{
				if(t[k]==undefined)
				{
					t[k]=values[i][k];
				}
				else{
					t[k]++;
				}
			}
		}
		return t;
	},
	{"out":"tt",
		"finalize":function(k,reduceVal){
			var maxcount=0;
			var s="";
			for(i in reduceVal)
			{
				if(reduceVal[i]>maxcount)
				{
					maxcount=reduceVal[i];
					s=i;
				}
			}
		return {"dt":k,"tag":s};	
		}
		
	}

)
输出：
[
        {
                "day" : "2012-12-14",
                "tag" : "nosql"
        },
        {
                "day" : "2012-5-10",
                "tag" : "struts 2"
        },
        {
                "day" : "2012-4-3",
                "tag" : "c#"
        }
]