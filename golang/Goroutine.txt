Go 语言 在 操作系统提供的内核线程 之上 搭建了一个 特有的两级线程模型，
 称之为  Goroutine,
 而Channel 可以保证在 Goroutine 之间 进行  共享数据传递时保证同步性
 同时 Go 语言仍提供了 传统的并发控制方法: 互斥量、条件变量 等
 
 1.线程 实现模型：
   (1)核心元素：
       M : Machine, 一个M 表示 一个内核线程
	   P : Processor, 一个P 代表 M所需的上下文环境
	   G : Goroutine, 一个 G 代表 一段 需要 被 并发执行的Go语言 代码封装
	   
	   一个G 的执行 需要 M 和P的支持，一个M 和P 关联后形成一个有效的G 运行环境(内核线程和上下文环境)
	   每个 P 包含 一个 可运行的G 的队列
	   
	   
	   关联关系 ：
	     M  和 KSE 是一一对应的， 一个M  只能代表一个内核线程，且只会与一个KSE 产生关联
		   Go 语言的运行时系统(runtime system) 中 以其 作为 一个 内核调度实体
		 M 和 P 总是 一对一 的，但 关联的 M 和 P 是不固定的
		 P 和 G 时 一对多的，且 在 实际调度中 关联会改变
		 M 和G 也会 建立关联，因为 一个 G 终归会由 一个 M 来负责运行
	   
    (2) M:
	    一般 在没有足够的M 来关联 P时，才会创建一个 M，
		  另 在运行时系统  执行 系统监控或垃圾回收等 任何时也会将导致创建新M
		 a.主要字段：
		     curg  保存 当前M 正在运行 的G 的指针，
			 p 指向 当前M 关联的P，
			 mstartfm 表示 M 的起始函数
			 nextp 会暂存 与当前M 潜在关联关系 的P 
		 b. M 在创建 之初 会加入 全局 的 M列表 (runtime.allm) ,
		    然后 其起始函数 和准备关联的P 将被设置，
			最后 运行时 系统 会为其专门 创建一个新的内核线程 并与之关联
			
		 c. 新的M 创建后 会先 进行 初始化，比如：栈空间 和信号处理的初始化
             在完成 初始化后，若 存在 起始函数，则会执行该起始函数
			   若 该起始函数 代表 的是 系统监控任务，则 该M 将一直执行，而不会继续下面的流程
			   否则，则 在执行完起始函数后，M 将于 P 进行关联，形成 一个并发执行环境
		 d.当 M 停止后， 运行时系统会对其的属性进行必要的重置，
		      然后 将其 放入到  调度器的 空闲 M 列表(runtime.sched.midle)
			  当需要一个 M 时，会先尝试 从该列表中获取
	 (3)P:
           Go 运行时系统 会 合时 让 P与 不同的M 建立关联，以使P 中的 可运行的 G 在需要时执行
          a. 当 M 因系统调用的进行 而被阻塞时，即其 运行的G 进入系统调用，
		      运行时系统 会将 该 M 和与之关联的P 分离，
			    此时 若 P 的可运行G队列 中 还有 未被运行的 G 时，则 运行时系统 会找个空闲 M，
				  或 创建一个新 M  与之关联
			 因此 M 的个数 不一定 等于 P 的个数，实际上 一般大于 P 的个数
		  b. Go 程序 在运行时，引导程序 会设置P 最大数量， 
		        该值  默认值为1，可通过 环境变量 GOMAXPROCS ，或runtime.GOMAXPROCS()设置
		  c. 在 确定P 的最大数量后，运行时系统  根据该值 初始化 全局 P列表(runtime.allp)
             然后 运行时系统 会把 调度器的 可运行G 队列(runtime.sched.runq) 中的 所有G 放入到
        		全局 P列表 中的各个P 的可运行 G 队列中
          d. 调度器的空闲P 列表 runtime.sched.pidle
               当 一个P  不再与 M 关联时， 运行时系统 会将 其放入该列表
          e. P 状态：
                I. Pidle 表示 P 未与任何M 存在关联
                II. Prunning  表示 P 正在与 某个 M 关联
                III. Psyscall 表示 当前P 中的被运行的G 正在进行系统调用
                IV. Pgcstop  表示 运行时系统 正在进行 垃圾回收，
                             当 运行时系统 进行 垃圾回收时，会试图将 全局P 列表中的P 都置于该状态
                V. Pdead 表示 P 不会再被使用
              P 的最初状态为  Pgcstop,该状态很短，随后初始化和填充 可运行G 队列后，
                 将状态 设置为 Pidle
              在 P 状态转换为 Pdead前，会 将其 可运行G 队列中的 G 转移到调度器的 可运行G 队列中，
                  其自由 G列表 中的G  将转移到 调度器的 自由G列表中，
				然后 将 P 进行销毁
        

		f. 每个P 中 都有一个 可运行 G队列， 还有一个 自由G列表，
		      该列表 包含 一些已经被运行完成的G，
			   当该列表 中的 G 过多时，则 运行时系统 会将部分G 转移 到调度器的自由G列表(runtime.sched.gfree)
             当要启用一个 G 时，则 运行时系统 会先试图 	从相应的P 的自由G列表中
               获取一个G 封装 要执行的 函数
               若 没有 现有的G 时，则 才会创建一个 G
      (4) G	
           一个 G 相当于 一个 Goroutine,即 与调用 go 开启并发时的 指定的函数向对应
          a. Go 编译器会将 go 语句 变成 对一个 运行时系统中的函数的调用，
              并 将 go 语句中的 函数 及其参数  作为 参数 传递到 该 运行时系统中的函数，
            运行时系统 在接受到 该调用后，先检查 传入 的 函数及其参数的合法性，
             然后 试图从 本地P 的自由G列表中或 调度器的自由G列表 中 获取一个G
                或 新建一个 G(并将其添加到 全局G列表 runtime.allg)，
             然后 对获取到的G(不论哪种形式获取到的) 进行初始化，包括关联 传入的函数，设置状态和ID等
			 再 将 G 放入到 本地P 的可运行G队列
		 b. G 状态：
		      I. Gidle 当G 刚创建 还没有初始化时，
			  II. Grunnable 表示 当前G 可运行，等待被运行
			  III. Grunning 表示 正在运行
			  IV. Gsyscall 表示 正在进行系统调用
			  V. Gwaiting  正在 因某个原因 而等待
			  VI. Gdead 表示已运行完成
			  
			  
			  
			 其中：
			   i. Gwaiting 状态，一般为 如 等待通道数据、网络IO，time.Sleep()等调用，
			        在结束等待后 将转为 Grunnable 状态
			   ii. G 在退出系统调用时， 运行时系统会先尝试直接运行该G
			        当 该G 无法 直接运行时，才会将其转为 Grunnable状态 并放到 调度器自由G列表，
					
			   iii. 进入 Gdead 状态的 G 是可被重新初始化并使用的
	
	
	(5)核心元素容器：
	     源码中名称     中文名称     作用域
	     runtime.allm  全局M 列表    运行时系统
		 runtime.allp  全局P 列表    运行时系统
	     runtime.allg  全局G 列表    运行时系统
         runtime.sched.midle  调度器空闲M 列表  调度器
         runtime.sched.pidle  调度器空闲P 列表  调度器
         runtime.sched.runq  调度器可运行G 队列  调度器
         runtime.sched.gfree  调度器自由G 列表  调度器
		 runq             P的可运行G队列   本地P
		 gfree            P的自由G列表   本地P