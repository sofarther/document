1.类型 是否相同判断：
  (1)如果类型不同时，在比较时会引发恐慌
      对于 类型别名，与其源类型也是不能进行比较的
	  type MyInt int
	  
	   var m MyInt =23
	    n :=23
		fmt.Println(m ==n) //错误
  (2)对于 数组类型，若 它们的长度一致且元素类型相同，
     则 视为 相同类型
  (3)对于切片类型，若 它们的元素类型相同，则 视为相同类型
  (4) 对于 结构体类型,若它们字段声明的数量 和顺序相同，且字段名和类型相同，
     则 视为 相同类型
	  如果 其中一个结构体 的字段为匿名字段，则另一个结构体相应的字段也必须为匿名字段
	    否则 则为不相同类型
  (5)对于 指针类型 ，若它们指向的类型 是相同的，则它们就是相同类型
  (6)对于 函数类型，若 它们包含相同的参数声明 和结果声明，则为相同类型
       其中 只将 参数 和结果 的 数量 类型 顺序 相同，不包括参数名 和结果名是否相同
  (7) 对于 接口类型， 若它们拥有相同的方法集合，则 为相同类型
        其中 方法顺序 任意
  (8) 对于字典类型，若 它们具有相等的键类型 和元素类型，则为相同类型
  (9) 对于 通道类型， 若它们 具有相同的元素类型，且方向相同，则为相同类型
 
  说明：
    若两个类型 不在同一个代码包中，则视为不相同类型

2. 类型值 可比性 和有序性：
     可比性 值 可作相等判断， 有序性指可进行大小比较
    (1) bool 类型 只能 作是否相等判断，不能进行值比较大小
     (2) 整型 浮点 复数 可作相等判断 和 比较大小 
     (3)字符串 可作相等判断 和 比较大小 
    (4)指针类型 具有 可比性， 当 指向同一个变量或 都为 nil,则为 相等
     (5)通道类型 具有可比性， 当元素类型 和缓冲区大小 都一致时，则 为相等
    (6)	接口类型 具有可比性：判断 接口的动态类型 是否相等
	     type Ic interface {
				Code() string
		}
        //接口的动态类型
		type Sc struct {
			m int
		}

		func (self Sc) Code() string {
			return string(self.m)
		}
        
		var ic1 Ic = Sc{65}
	    var ic2 Ic = Sc{65}
		//通过 接口的动态类型值 比较判断
		fmt.Println(ic1 == ic2) 	
		
	   接口类型 可以与 实现该接口的动态类型 进行比较，当接口的实际类型 与该动态类型 相同时，则为相等
        	var sc1 Sc = Sc{65}
			//Sc类型 变量 和 接口类型变量 比较 
		fmt.Println( ic1 == sc1, ic2 == sc1)  //true,true	
		   
	  