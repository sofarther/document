
2017.10.14
1.在函数中 会有默认的 静态局部变量 __func__
int add(int num1, int num2)
{
	std::cout << "Enter function " << __func__ << std::endl;
	return num1 + num2;
}
也可以 在类方法中使用， 返回 纯的方法名
__FILE__ 表示当前文件名， __LINE__ 表示 当前行数
2. 虚函数不能 声明为 const
	当函数 声明为const 时， 则 在该函数中调用的其他方法 也必须 使用 const 修饰， 否则会报错：
		 如：error: passing ‘const GameBoard’ as ‘this’ argument of ‘void GameBoard::checkRange(int, int)’ 
			discards qualifiers [-fpermissive]
	即 this 参数类型丢失
		 
3. 函数 返回 vector 指定的元素的引用时， 当向 vector 中添加元素时，导致 该元素的地址改变，
	因此 当 对 返回的引用 变量修改， 并不会影响到 vector 中的该元素，
	不要将对象直接放到 集合中， 而使用 指向对象的指针或 智能指针
4.必须在构造函数初始化列表中 进行初始化：
		(1) const 数据成员
		(2)引用类型数据成员
		(3) 没有默认构造函数 的对象数据成员
		(4) 没有默认构造函数 的父类
	构造函数的初始化列表  按照 在类中声明的属性 顺序进行初始化 ,而不是 初始化列表顺序	
5. C++11 中 构造函数中 使用 std::initializer_list<T> 作为参数，
	std::initializer_list<T> 位于 initializer_list 头文件
		PointSequence(initializer_list<double> args)
			
	此时，不能使用 
		PointSequence p2(2.5,6.8,3.5,5.6);	
	形式进行初始化	
	 当 std::initializer_list<T> 为第一个参数 ，其他参数为带有默认值的参数时，
	 可以使用
		PointSequence p1={1.0,2.0,3.0,4.0,5.0,6.0};
		
	若参数列表中有其他没有默认值的参数时，
			PointSequence(initializer_list<double> args,int k, char c)
	则使用该形式：
		initializer_list<double> params={2.5,4.7,5.8,3.6};
		PointSequence p2 (params,10,'m');
	在函数中 可以使用 args.size() 获取传入的参数个数， 并 可以通过 begin() 和end() 获取迭代器来遍历传入的参数

	还可以使用{} 统一初始化， 其中的顺序为 构造函数 参数列表顺序：
		Person ps{"hello",1,23,54.6};
		参数类型可以不同
6. 类声明的头文件中， 只能初始化 static const int,  static const char 类型
		但不能初始化 static const double 或 static const string 等类型
		也不能 初始化 static 静态变量
		在 C++11 中可以初始化 const 常量
		
	静态成员 可以 在非静态方法中访问
	       当为公有属性时， 可以通过 对象引用	
	const 非静态 成员 不能在静态方法中访问，
			
		当为公有属性时，可以通过对象引用，
			但不能通过 类名:: 访问
	静态方法 只能访问静态属性，
		 当为公有属性时，可以通过对象引用、
		 静态方法不能声明为 const 修饰， 也不能是 virtual 虚方法
		静态方法 不能被子类重载，若在子类中，声明相同的静态方法，则
			存在两个方法，以 类名限定符 来区分
			当 使用对象 或对象指针来调用静态方法时，则会根据 该对象或对象指针声明的类型，
			来判断调用 父类或子类中的该静态方法，而不是该对象实际的对象类型
		若在子类中，没有声明相同的静态方法，则 子类对象在调用该方法时，则将调用父类的静态方法	
			也可以 使用 子类::静态方法 来访问 父类静态方法
7.mutable 修饰一个成员变量，则该成员 将永远处于可变的状态，即使在一个const函数中 
			 mutable int mNumAccess; 
			int getK() const {mNumAccess++; return k;}	
	如果mNumAccess 前面 有static 或者const修饰，则会编译出错。	
8. 子类重载 父类的 某个方法，当在父类中该方法名有多个重载形式时，
		则 子类只会继承 该重载的形式，其他形式则会隐藏，
		即不能 通过子类对象 调用 该方法的其他形式
		
	 但可以 使用指向子类的对象的 父类指针 调用 父类中的该方法其他形式
    
	可以 在子类中 public 通过 using 父类::方法名; 形式 声明父类该方法的其他形式	
		其中 方法名 后没有()
	在C++11 中可以 对 父类的构造函数 使用该形式进行声明，即可以调用父类的构造函数来创建子类对象，
		其中 对于 在子类中声明的属性，则可以在 C++11 中在声明时提供默认值
	当 在子类中声明了与父类构造函数 参数相同的构造函数时，则会优先使用 子类声明的构造函数	
9. 修改 方法的访问权限：
		子类可以修改 父类的方法的权限：
		(1)将 父类的方法权限 严格：
			 使用 子类对象 不能调用该方法，但父类对象 可以调用
			当 父类引用或指针 引用 子类对象，则也可以调用该方法，并调用子类方法（virtual 声明）
			即 子类的 限制的方法 仍可以在外部方法
		(2)将 父类的方法权限 放大：
			父类对象 和 父类引用 指针 引用子类对象 都不能访问该方法，
			子类对象 可以访问该方法
10. 子类重载 父类 中带有默认参数 的方法	
	  该默认参数不会被继承， 
	  当 子类在重载 该方法时 重新指定了新参数时，则
		当 使用 父类引用或指针 引用子类对象 不传入参数来调用该方法时，则会调用子类中的该方法（virtual 声明），
		但 默认参数 仍为 父类声明中的默认值
	当 子类在重载 该方法时，没有指定默认参数，则相当于 重载了该方法的 一个新形式， 则父类的待默认参数的形式会被隐藏，
		因此 子类对象不能 不传入参数调用 该方法
11. 不同源文件 中的 非局部变量（外部连接性）的初始化顺序 不确定
		在 命名空间中的变量 在多个源文件中使用：
			在 头文件中定义
			namespace NS{
				extern int m;
			};
				
			在源文件中初始化：first.cpp
				namespace NS{
					extern int m;
					m=20;
				};
				
			不能直接 使用 extern int m=20;
			在 主文件中使用：
				using namespace NS;
				extern int NS::m;
			必须在 main() 函数外，且 必须使用 命名空间限定符，即使使用了 using namespace NS; 

12. typedef 定义函数指针 类型
		 typedef int (*myf)(bool b, int i, const char *p);
	其中 myf 为 指向 参数为 (bool b, int i, const char *p)， 返回值为 int 的函数指针类型
		定义变量
		myf f;
	C++11 中 使用 using 来 声明：
		using myf = int (*)(bool b, int i, const char *p)
13. 当 函数在定义和声明时， 声明的 异常列表，则
			若在该函数中 抛出的 没有在 异常列表 中的 异常时，
		则 会阻止该异常离开 该函数而抛出到调用该函数的上级函数中，
		因此 调用函数 无法捕捉到该意外异常
		而是会直接调用 unexpected() 处理该意外异常
		可以通过 set_unexpected() 设置 处理意外异常函数，
				若 在该 处理意外异常 函数中， 再调用 throw 抛出异常，
				则 若该新的异常 仍没有在 声明的异常列表中，
					则 若 该声明的异常列表中有 bad_exception ,
						则 无论 在该 处理意外异常 函数中 抛出的是 任何异常，
							都将抛出  bad_exception 到 调用函数
						否则 终止程序
	子类重写父类方法， 可以将 父类中的方法 声明的 异常列表 中的异常进行删除
			也可以 使用 noexcept 或 清空 异常列表
			也可以 添加新的异常， 但该异常必须为 父类中的异常列表的子类
	
	作为异常抛出的对象 至少会按值复制一次，
		因为 在抛出时位置 创建的异常对象 所在的栈 位置较高，可能会在抛出后而捕捉之前，
			该对象内存已回收，因此会进行一次 按值赋值
	因此在创建自定义异常类时，
		需实现复制构造函数、赋值运算符、 当有内存分配时，析构函数需释放分配的内存
14.右值引用用来绑定到右值,绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期,
	可以理解为 赋予了那个临时对象一个合法地位:一个名字，
	因此本来本来要被销毁的临时对象也会由于变量绑定而将生存期延长至和变量一样	
15.
	(1) new new[] 无法分配内存时，将 抛出 bad_alloc 异常， 因此 
		可以通过捕捉该异常
		也可以 使用 添加nothrow 表示 不抛出异常，而是通过 空指针判断
	
		try{
    
			
				int bgsize =1000 * 1024*1024;
				int * bigInt = new int[bgsize];
				set_new_handler(oldHandler);
			//使用 空指针判断
			//int * bigInt = new(nothrow) int[bgsize];

			//if(bigInt == nullptr)
			 // {
			//	cerr << "allocate memory fail\n";
			//	return 2;
			//  }
			delete [] bigInt;

  }
  catch(const bad_alloc &e)
    {
      cerr << __FILE__ <<"("<< __LINE__ << "): Unable to allocate memory\n";
      return 1;
    }
	还可以 设置 分配内存失败的回调方法：
		set_new_handler()
		返回 原  new_handler 
		
				void myNewHandler()
				{
				  cerr << __func__ << ": allocate memory fail\n";
				
				  // throw TerminateMe();
				  throw bad_alloc();
				}

		new_handler oldHandler = set_new_handler(myNewHandler);
	默认下 new handler 为空， 因此会抛出异常，若设置了  new handler, 则不会抛出异常而调用该回调函数，
	new handler 回调函数限制：
		a. 当该回调函数 会返回时， 则程序将会继续分配内存，从而造成递归调用，
			因此 可以 在该回调函数中 抛出异常，
				该异常可以由顶层函数，如 main() 函数处理，并终止程序，
		b. 回调函数 当抛出除 bad_alloc 异常（或其子类）外， 则会调用 set_unexpected() 设置的意外异常处理函数
				默认下会终止程序，
		c. 在回调函数中 不要调用 abort()或 exit() 退出程序
		d. 若 保证 在分配内存异常，程序仍可以执行，则可以在 回调函数中 将 new_handler 设置为 空，
			否则会造成递归调用
	
	(2) 构造函数中异常：
			当在构造函数中抛出异常时，则该对象没有创建，因此 不能调用析构函数释放分配的内存，
			因此必须在构造函数中处理该异常，而不能将其 抛到上级函数中，
			
			Matrix::Matrix(unsigned int width, unsigned int height) throw(bad_alloc)
			  : mWidth(width),mHeight(height),mMatrix(nullptr), mElem(width)
			{
			  unsigned int i=0;
			  mMatrix = new Element* [width];
			  try{
			  for(i=0; i<width;i++)
				{
				  mMatrix[i]= new Element[height];
				}
			  }catch(...)
				{
				//清理分配的内存
				  cout << "Exception caught in constructor, cleaning up...\n";

				  for(unsigned int j=0; j< i; j++)
					{
					  delete [] mMatrix[j];
					}
				  delete [] mMatrix;
				  mMatrix=nullptr;
				  throw bad_alloc();
				}

			}
		对于 在 构造函数的初始化列表 中的异常，则可以通过以下形式进行捕捉：
			Matrix::Matrix(unsigned int width, unsigned int height) throw(bad_alloc,runtime_error)
			try
			  : mWidth(width),mHeight(height),mMatrix(nullptr), mElem(width)
			{
				...
				...
			}catch(const std::exception & e)
			  {
				cout << "function-try-block caught\n";
			  }
		其中 try 在初始化列表前， 而 catch 在 构造函数结束的} 后
		限制：
			a. catch 语句 可以捕捉 初始化和 构造函数中的 所有异常，
			b. catch 语句 仍会抛出抛出异常，若没有在 catch 中进行显式抛出，
				则会默认将捕捉到的异常再次抛出
			c. 在 catch 捕捉到异常时， 则已经创建的成员对象都会 在 catch 前 调用 该对象析构函数，进行销毁
				因此 不应该 在 catch 中访问 成员的变量（测试仍可以访问到，尽管已调用 析构函数）
				
		(3)析构函数 异常：
			必须 在析构函数内部中处理析构函数引发的所有错误，而不应该 在析构函数中 向外抛出任何异常