
2017.10.14
1.在函数中 会有默认的 静态局部变量 __func__
int add(int num1, int num2)
{
	std::cout << "Enter function " << __func__ << std::endl;
	return num1 + num2;
}
也可以 在类方法中使用， 返回 纯的方法名
2. 虚函数不能 声明为 const
3. 函数 返回 vector 指定的元素的引用时， 当向 vector 中添加元素时，导致 该元素的地址改变，
	因此 当 对 返回的引用 变量修改， 并不会影响到 vector 中的该元素，
	不要将对象直接放到 集合中， 而使用 指向对象的指针或 智能指针
4.必须在构造函数初始化列表中 进行初始化：
		(1) const 数据成员
		(2)引用类型数据成员
		(3) 没有默认构造函数 的对象数据成员
		(4) 没有默认构造函数 的父类
	构造函数的初始化列表  按照 在类中声明的属性 顺序进行初始化 ,而不是 初始化列表顺序	
5. C++11 中 构造函数中 使用 std::initializer_list<T> 作为参数，
	std::initializer_list<T> 位于 initializer_list 头文件
		PointSequence(initializer_list<double> args)
			
	此时，不能使用 
		PointSequence p2(2.5,6.8,3.5,5.6);	
	形式进行初始化	
	 当 std::initializer_list<T> 为第一个参数 ，其他参数为带有默认值的参数时，
	 可以使用
		PointSequence p1={1.0,2.0,3.0,4.0,5.0,6.0};
		
	若参数列表中有其他没有默认值的参数时，
			PointSequence(initializer_list<double> args,int k, char c)
	则使用该形式：
		initializer_list<double> params={2.5,4.7,5.8,3.6};
		PointSequence p2 (params,10,'m');
	在函数中 可以使用 args.size() 获取传入的参数个数， 并 可以通过 begin() 和end() 获取迭代器来遍历传入的参数

	还可以使用{} 统一初始化， 其中的顺序为 构造函数 参数列表顺序：
		Person ps{"hello",1,23,54.6};
		参数类型可以不同
6. 类声明的头文件中， 只能初始化 static const int,  static const char 类型
		但不能初始化 static const double 或 static const string 等类型
		也不能 初始化 static 静态变量
		在 C++11 中可以初始化 const 常量
		
	静态成员 可以 在非静态方法中访问
	       当为公有属性时， 可以通过 对象引用	
	const 非静态 成员 不能在静态方法中访问，
			
		当为公有属性时，可以通过对象引用，
			但不能通过 类名:: 访问
	静态方法 只能访问静态属性，
		 当为公有属性时，可以通过对象引用、
		 静态方法不能声明为 const 修饰， 也不能是 virtual 虚方法
		静态方法 不能被子类重载，若在子类中，声明相同的静态方法，则
			存在两个方法，以 类名限定符 来区分
			当 使用对象 或对象指针来调用静态方法时，则会根据 该对象或对象指针声明的类型，
			来判断调用 父类或子类中的该静态方法，而不是该对象实际的对象类型
		若在子类中，没有声明相同的静态方法，则 子类对象在调用该方法时，则将调用父类的静态方法	
			也可以 使用 子类::静态方法 来访问 父类静态方法
7.mutable 修饰一个成员变量，则该成员 将永远处于可变的状态，即使在一个const函数中 
			 mutable int mNumAccess; 
			int getK() const {mNumAccess++; return k;}	
	如果mNumAccess 前面 有static 或者const修饰，则会编译出错。	
8. 子类重载 父类的 某个方法，当在父类中该方法名有多个重载形式时，
		则 子类只会继承 该重载的形式，其他形式则会隐藏，
		即不能 通过子类对象 调用 该方法的其他形式
		
	 但可以 使用指向子类的对象的 父类指针 调用 父类中的该方法其他形式
    
	可以 在子类中 public 通过 using 父类::方法名; 形式 声明父类该方法的其他形式	
		其中 方法名 后没有()
	在C++11 中可以 对 父类的构造函数 使用该形式进行声明，即可以调用父类的构造函数来创建子类对象，
		其中 对于 在子类中声明的属性，则可以在 C++11 中在声明时提供默认值
	当 在子类中声明了与父类构造函数 参数相同的构造函数时，则会优先使用 子类声明的构造函数	
9. 修改 方法的访问权限：
		子类可以修改 父类的方法的权限：
		(1)将 父类的方法权限 严格：
			 使用 子类对象 不能调用该方法，但父类对象 可以调用
			当 父类引用或指针 引用 子类对象，则也可以调用该方法，并调用子类方法（virtual 声明）
			即 子类的 限制的方法 仍可以在外部方法
		(2)将 父类的方法权限 放大：
			父类对象 和 父类引用 指针 引用子类对象 都不能访问该方法，
			子类对象 可以访问该方法
10. 子类重载 父类 中带有默认参数 的方法	
	  该默认参数不会被继承， 
	  当 子类在重载 该方法时 重新指定了新参数时，则
		当 使用 父类引用或指针 引用子类对象 不传入参数来调用该方法时，则会调用子类中的该方法（virtual 声明），
		但 默认参数 仍为 父类声明中的默认值
	当 子类在重载 该方法时，没有指定默认参数，则相当于 重载了该方法的 一个新形式， 则父类的待默认参数的形式会被隐藏，
		因此 子类对象不能 不传入参数调用 该方法
11. 不同源文件 中的 非局部变量（外部连接性）的初始化顺序 不确定
		在 命名空间中的变量 在多个源文件中使用：
			在 头文件中定义
			namespace NS{
				extern int m;
			};
				
			在源文件中初始化：first.cpp
				namespace NS{
					extern int m;
					m=20;
				};
				
			不能直接 使用 extern int m=20;
			在 主文件中使用：
				using namespace NS;
				extern int NS::m;
			必须在 main() 函数外，且 必须使用 命名空间限定符，即使使用了 using namespace NS; 

12. typedef 定义函数指针 类型
		 typedef int (*myf)(bool b, int i, const char *p);
	其中 myf 为 指向 参数为 (bool b, int i, const char *p)， 返回值为 int 的函数指针类型
		定义变量
		myf f;
	C++11 中 使用 using 来 声明：
		using myf = int (*)(bool b, int i, const char *p)
13. 当 函数在定义和声明时， 声明的 异常列表，则
			若在该函数中 抛出的 没有在 异常列表 中的 异常时，
		则 会阻止该异常离开 该函数而抛出到调用该函数的上级函数中，
		因此 调用函数 无法捕捉到该意外异常
		而是会直接调用 unexpected() 处理该意外异常
		可以通过 set_unexpected() 设置 处理意外异常函数，
				若 在该 处理意外异常 函数中， 再调用 throw 抛出异常，
				则 若该新的异常 仍没有在 声明的异常列表中，
					则 若 该声明的异常列表中有 bad_exception ,
						则 无论 在该 处理意外异常 函数中 抛出的是 任何异常，
							都将抛出  bad_exception 到 调用函数
						否则 终止程序
	子类重写父类方法， 可以将 父类中的方法 声明的 异常列表 中的异常进行删除
			也可以 使用 noexcept 或 清空 异常列表
			也可以 添加新的异常， 但该异常必须为 父类中的异常列表的子类
	
	作为异常抛出的对象 至少会按值复制一次，
		因为 在抛出时位置 创建的异常对象 所在的栈 位置较高，可能会在抛出后而捕捉之前，
			该对象内存已回收，因此会进行一次 按值赋值
	因此在创建自定义异常类时，
		需实现复制构造函数、赋值运算符、 当有内存分配时，析构函数需释放分配的内存
	