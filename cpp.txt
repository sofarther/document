
2017.10.14
1.在函数中 会有默认的 静态局部变量 __func__
int add(int num1, int num2)
{
	std::cout << "Enter function " << __func__ << std::endl;
	return num1 + num2;
}
也可以 在类方法中使用， 返回 纯的方法名
2. 虚函数不能 声明为 const
3. 函数 返回 vector 指定的元素的引用时， 当向 vector 中添加元素时，导致 该元素的地址改变，
	因此 当 对 返回的引用 变量修改， 并不会影响到 vector 中的该元素，
	不要将对象直接放到 集合中， 而使用 指向对象的指针或 智能指针
4.必须在构造函数初始化列表中 进行初始化：
		(1) const 数据成员
		(2)引用类型数据成员
		(3) 没有默认构造函数 的对象数据成员
		(4) 没有默认构造函数 的父类
	构造函数的初始化列表  按照 在类中声明的属性 顺序进行初始化 ,而不是 初始化列表顺序	
5. C++11 中 构造函数中 使用 std::initializer_list<T> 作为参数，
	std::initializer_list<T> 位于 initializer_list 头文件
		PointSequence(initializer_list<double> args)
			
	此时，不能使用 
		PointSequence p2(2.5,6.8,3.5,5.6);	
	形式进行初始化	
	 当 std::initializer_list<T> 为第一个参数 ，其他参数为带有默认值的参数时，
	 可以使用
		PointSequence p1={1.0,2.0,3.0,4.0,5.0,6.0};
		
	若参数列表中有其他没有默认值的参数时，
			PointSequence(initializer_list<double> args,int k, char c)
	则使用该形式：
		initializer_list<double> params={2.5,4.7,5.8,3.6};
		PointSequence p2 (params,10,'m');
	在函数中 可以使用 args.size() 获取传入的参数个数， 并 可以通过 begin() 和end() 获取迭代器来遍历传入的参数

	还可以使用{} 统一初始化， 其中的顺序为 构造函数 参数列表顺序：
		Person ps{"hello",1,23,54.6};
		参数类型可以不同
6. 类声明的头文件中， 只能初始化 static const int,  static const char 类型
		但不能初始化 static const double 或 static const string 等类型
		也不能 初始化 static 静态变量
		在 C++11 中可以初始化 const 常量
		
	静态成员 可以 在非静态方法中访问
	       当为公有属性时， 可以通过 对象引用	
	const 非静态 成员 不能在静态方法中访问，
			
		当为公有属性时，可以通过对象引用，
			但不能通过 类名:: 访问
	静态方法 只能访问静态属性，
		 当为公有属性时，可以通过对象引用、
		 静态方法不能声明为 const 修饰， 也不能是 virtual 虚方法
		静态方法 不能被子类重载，若在子类中，声明相同的静态方法，则
			存在两个方法，以 类名限定符 来区分
			当 使用对象 或对象指针来调用静态方法时，则会根据 该对象或对象指针声明的类型，
			来判断调用 父类或子类中的该静态方法，而不是该对象实际的对象类型
		若在子类中，没有声明相同的静态方法，则 子类对象在调用该方法时，则将调用父类的静态方法	
			也可以 使用 子类::静态方法 来访问 父类静态方法
7.mutable 修饰一个成员变量，则该成员 将永远处于可变的状态，即使在一个const函数中 
			 mutable int mNumAccess; 
			int getK() const {mNumAccess++; return k;}	
	如果mNumAccess 前面 有static 或者const修饰，则会编译出错。	
8. 子类重载 父类的 某个方法，当在父类中该方法名有多个重载形式时，
		则 子类只会继承 该重载的形式，其他形式则会隐藏，
		即不能 通过子类对象 调用 该方法的其他形式
		
	 但可以 使用指向子类的对象的 父类指针 调用 父类中的该方法其他形式
    
	可以 在子类中 public 通过 using 父类::方法名; 形式 声明父类该方法的其他形式	
		其中 方法名 后没有()
	在C++11 中可以 对 父类的构造函数 使用该形式进行声明，即可以调用父类的构造函数来创建子类对象，
		其中 对于 在子类中声明的属性，则可以在 C++11 中在声明时提供默认值
	当 在子类中声明了与父类构造函数 参数相同的构造函数时，则会优先使用 子类声明的构造函数	
9. 修改 方法的访问权限：
		子类可以修改 父类的方法的权限：
		(1)将 父类的方法权限 严格：
			 使用 子类对象 不能调用该方法，但父类对象 可以调用
			当 父类引用或指针 引用 子类对象，则也可以调用该方法，并调用子类方法（virtual 声明）
			即 子类的 限制的方法 仍可以在外部方法
		(2)将 父类的方法权限 放大：
			父类对象 和 父类引用 指针 引用子类对象 都不能访问该方法，
			子类对象 可以访问该方法
10. 子类重载 父类 中带有默认参数 的方法	
	  该默认参数不会被继承， 
	  当 子类在重载 该方法时 重新指定了新参数时，则
		当 使用 父类引用或指针 引用子类对象 不传入参数来调用该方法时，则会调用子类中的该方法（virtual 声明），
		但 默认参数 仍为 父类声明中的默认值
	当 子类在重载 该方法时，没有指定默认参数，则相当于 重载了该方法的 一个新形式， 则父类的待默认参数的形式会被隐藏，
		因此 子类对象不能 不传入参数调用 该方法
11. 不同源文件 中的 非局部变量（外部连接性）的初始化顺序 不确定
		在 命名空间中的变量 在多个源文件中使用：
			在 头文件中定义
			namespace NS{
				extern int m;
			};
				
			在源文件中初始化：first.cpp
				namespace NS{
					extern int m;
					m=20;
				};
				
			不能直接 使用 extern int m=20;
			在 主文件中使用：
				using namespace NS;
				extern int NS::m;
			必须在 main() 函数外，且 必须使用 命名空间限定符，即使使用了 using namespace NS; 

12. typedef 定义函数指针 类型
		 typedef int (*myf)(bool b, int i, const char *p);
	其中 myf 为 指向 参数为 (bool b, int i, const char *p)， 返回值为 int 的函数指针类型
		定义变量
		myf f;
	C++11 中 使用 using 来 声明：
		using myf = int (*)(bool b, int i, const char *p)
13. 当 函数在定义和声明时， 声明的 异常列表，则
			若在该函数中 抛出的 没有在 异常列表 中的 异常时，
		则 会阻止该异常离开 该函数而抛出到调用该函数的上级函数中，
		因此 调用函数 无法捕捉到该意外异常
		而是会直接调用 unexpected() 处理该意外异常
		可以通过 set_unexpected() 设置 处理意外异常函数，
				若 在该 处理意外异常 函数中， 再调用 throw 抛出异常，
				则 若该新的异常 仍没有在 声明的异常列表中，
					则 若 该声明的异常列表中有 bad_exception ,
						则 无论 在该 处理意外异常 函数中 抛出的是 任何异常，
							都将抛出  bad_exception 到 调用函数
						否则 终止程序
	子类重写父类方法， 可以将 父类中的方法 声明的 异常列表 中的异常进行删除
			也可以 使用 noexcept 或 清空 异常列表
			也可以 添加新的异常， 但该异常必须为 父类中的异常列表的子类
	
	作为异常抛出的对象 至少会按值复制一次，
		因为 在抛出时位置 创建的异常对象 所在的栈 位置较高，可能会在抛出后而捕捉之前，
			该对象内存已回收，因此会进行一次 按值赋值
	因此在创建自定义异常类时，
		需实现复制构造函数、赋值运算符、 当有内存分配时，析构函数需释放分配的内存
		
14. STL 可以使用容器保存的 元素对象的条件：
		(1)	STL 容器对元素使用 值语义， 即 在保存元素时，保存元素的副本，
			在请求元素时，返回 元素的副本， 而不是元素本身对象
			因此 要保存到 STL容器的 元素对象 必须保证 可以有多个副本而不会异常
		(2)需要实现的方法：
			复制构造函数、 赋值运算、 析构函数、 默认构造函数、
			operator==() 相等运算 operator<() 小于运算
			C++11中， 还可以实现 移动构造函数  和 移动赋值运算			
15. 在类模板中， 当使用的类型 需要传入 模板中的类型参数时，需显式指定 typename 关键字：
		template <typename T>
		class MyClass
		{
			...
			std::vector<T> mElems;
			typename std::vector<T>::iterator mCurElem;
			...
		};
		其中 模板参数T 用于访问 迭代器类型，故指定 typename	
16. list：双向列表， 不支持随机访问元素，
			可以通过front() 和back() 返回第一个和最后一个元素
	(1)	迭代器 不能进行 加减运算， 
		auto iterInsert =++(words.begin());
		words.begin()+1 报错
	(2) 插入 其他list 元素：
		//将指定的list 元素全部插入， 参数的list 会被清空
			void splice ( iterator position, list<T,Allocator>& x ); 
		// 将指定的list 的一个元素插入， 参数中list 的该元素会被删除
			void splice ( iterator position, list<T,Allocator>& x, iterator i );
		//将指定的list 的 指定范围元素插入， 参数中list 的该范围的元素被删除
			不包括 last 指向的元素
		void splice ( iterator position, list<T,Allocator>& x, iterator first, iterator last );	
	(3)merger() 合并list
		void merge (list& x, Compare comp);
		 有序合并指定的list, 并会清空参数list
		其中 Compare 指定排序的比较函数：
			bool myComp(double first,double second)
			返回 true 表示 第一个参数 顺序排在第二个参数前
		默认下会调用 元素 的operator<() 运算操作符进行比较	
		list1.merge(list2,myComp);	
		合并排序规则：
			将 参数list 的元素与调用该方法的list 对象中的元素 进行比较，
    		从而找到要合并的位置，
    		但不会和 参数list 中的元素进行比较，而是仍按照该list 中的顺序合并到新的list 中
    	例如： list1 为： 3.1 2.2 6.9
    		list2 为 3.7 7.1 1.4 2.5 4.0
    		在合并后， list1 为 
    			3.1 2.2 3.7 6.9 7.1 1.4 2.5 4
		因此，应在调用merge()前， 对两个list 对象调用 sort()进行排序
			可以指定排序比较函数 list2.sort(myComp)
	(4)	unique() 只能去掉连续重复的元素	
		remove(元素值) 删除 与 指定的元素值 相等的所有元素
		erase(position) 删除迭代器指定位置的元素
		 并返回 该已删除的 位置，但与传入参数不同
		 该返回值 可通过 * 获取删除的元素值， 可以通过++ 或-- 获取删除的元素的前后位置
		 但不能使用 传入的 postion 对象来操作list元素
		erase(first,last) 删除指定区间的元素
		
		auto secIter1 =second.erase(secIter);
    	//返回的位置和传入的参数 不相同
   		 cout <<*secIter1<< (&secIter1 ==&secIter) <<endl;
     	//移动 删除的位置，否则会报错
		secIter1++;
		//secIter++;
		auto secIter2 =--(second.end());
		//在删除 secIter 位置的元素后，不能再使用 secIter 来指定位置
		//而使用 返回的 secIter1 来指定位置
		second.erase(secIter1,secIter2);
17 forward_list 单向列表 C++11 中
		在插入操作时，指定的插入位置 只能是在该位置后进行插入，而不能为在该位置前插入，
		因此 调用 insert_after() 或 splice_after()
		
		而获取列表开头位置，调用 before_begin(), 即获取列表头前的位置
		获取最后的元素， 由于不支持--不能使用 (-- for_list.end())
		 只能通过开头进行遍历获取：
		 	auto iter = lst1.before_begin();
		 	auto iterTmp =iter;
			while(++iterTmp!=lst1.end())
			{
				++iter;
			}
18. queue 队列：
		push() 向尾部添加元素 pop()从头部弹出元素，
			其中 pop()不会返回弹出的元素，需先通过front()获取该元素引用，
			然后再调用pop()方法
			back()获取尾部元素引用
	priority_queue() 位于 queue 头文件，
			通过 元素的 operator< 运算 判断元素的优先级，优先级高的先弹出
			故 添加到priority_queue 元素的类 有该运算操作符
			top() 返回优先级高的元素
			pop()将优先级高的元素弹出
	statck 栈：
			top() 返回 栈最上的元素
			pop() 弹出栈最上 的元素						
